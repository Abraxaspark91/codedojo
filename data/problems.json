[
  {
    "pid": "sql_select_filter",
    "title": "신규 고객 목록 조회",
    "body": "customers 테이블에서 가입일이 2024-01-01 이후인 고객의 id, name, signup_date를 최근 가입일 순으로 조회하세요.",
    "schema": "customers(id INT, name TEXT, signup_date DATE)",
    "sample_rows": [
      "1 | Alice | 2024-02-10",
      "2 | Bob | 2023-12-30",
      "3 | Casey | 2024-03-01"
    ],
    "difficulty": "Lv1 입문",
    "kind": "sql",
    "expected": ["SELECT", "WHERE", "ORDER BY"],
    "hint": "기본 SELECT와 WHERE 조건, ORDER BY로 정렬합니다."
  },
  {
    "pid": "sql_aggregation_monthly",
    "title": "월별 매출 합계 구하기",
    "body": "sales 테이블에서 월별 총 매출액을 계산하세요. 컬럼은 month, total_sales 로 하고 결과는 월 오름차순으로 정렬하세요.",
    "schema": "sales(order_date DATE, amount DECIMAL)",
    "sample_rows": [
      "2024-01-05 | 120000",
      "2024-01-18 | 98000",
      "2024-02-02 | 150000"
    ],
    "difficulty": "Lv2 초급",
    "kind": "sql",
    "expected": ["GROUP BY", "SUM", "ORDER BY"],
    "hint": "GROUP BY와 DATE_TRUNC 또는 MONTH 함수를 활용해 월 단위로 묶으세요."
  },
  {
    "pid": "sql_join_customer_orders",
    "title": "고객별 주문 금액 합계",
    "body": "customers(cust_id, name)와 orders(order_id, cust_id, amount) 테이블을 조인해 고객 이름과 총 주문 금액을 조회하세요. 금액이 높은 순으로 정렬하세요.",
    "schema": "customers(cust_id INT, name TEXT)\norders(order_id INT, cust_id INT, amount DECIMAL)",
    "sample_rows": [
      "customers: 1 | Alice",
      "customers: 2 | Bob",
      "orders: 10 | 1 | 50000",
      "orders: 11 | 1 | 30000",
      "orders: 12 | 2 | 45000"
    ],
    "difficulty": "Lv3 중급",
    "kind": "sql",
    "expected": ["JOIN", "GROUP BY", "SUM", "ORDER BY"],
    "hint": "INNER JOIN으로 연결한 뒤 cust_id를 기준으로 SUM(amount)를 집계합니다."
  },
  {
    "pid": "sql_window_rank",
    "title": "카테고리별 최고 판매 상품 찾기",
    "body": "products(id, category, price) 테이블에서 카테고리별로 가장 비싼 상품의 id와 price를 구하세요.",
    "schema": "products(id INT, category TEXT, price DECIMAL)",
    "sample_rows": [
      "1 | electronics | 120000",
      "2 | electronics | 99000",
      "3 | books | 18000"
    ],
    "difficulty": "Lv4 고급",
    "kind": "sql",
    "expected": ["ROW_NUMBER", "PARTITION BY", "ORDER BY"],
    "hint": "ROW_NUMBER() OVER(PARTITION BY category ORDER BY price DESC)로 1순위만 남기세요."
  },
  {
    "pid": "sql_running_total",
    "title": "월별 누적 매출 계산",
    "body": "sales(month, amount)에서 월별 매출과 누적 매출 cum_sales를 구하세요. 월 기준 오름차순으로 출력하세요.",
    "schema": "sales(month TEXT, amount DECIMAL)",
    "sample_rows": [
      "2024-01 | 200000",
      "2024-02 | 230000",
      "2024-03 | 180000"
    ],
    "difficulty": "Lv5 심화",
    "kind": "sql",
    "expected": ["SUM", "OVER", "ORDER BY", "PARTITION"],
    "hint": "CTE로 월별 집계를 만든 뒤 SUM(amount) OVER(ORDER BY month)로 누적합을 계산합니다."
  },
  {
    "pid": "pyspark_basic_filter",
    "title": "활성 사용자 필터링",
    "body": "users DataFrame에서 active가 True이고 last_login이 2024-01-01 이후인 사용자만 남기고 id와 last_login 컬럼을 선택하세요.",
    "schema": "users(id INT, active BOOLEAN, last_login TIMESTAMP)",
    "sample_rows": [
      "1 | true | 2024-02-03",
      "2 | false | 2023-12-10",
      "3 | true | 2024-01-12"
    ],
    "difficulty": "Lv1 입문",
    "kind": "python",
    "expected": ["filter", "select"],
    "hint": "filter로 조건을 연결하고 select로 필요한 컬럼만 남깁니다."
  },
  {
    "pid": "pyspark_join",
    "title": "고객 주문 통계 만들기",
    "body": "customers와 orders DataFrame이 주어졌을 때, 고객별 주문 건수와 총 금액을 계산하는 DataFrame을 만들고 order_count, total_amount 컬럼을 추가하세요.",
    "schema": "customers(cust_id INT, name STRING)\norders(order_id INT, cust_id INT, amount DOUBLE)",
    "sample_rows": [
      "customers: 1 | Alice",
      "customers: 2 | Bob",
      "orders: 10 | 1 | 50000.0",
      "orders: 11 | 1 | 25000.0",
      "orders: 12 | 2 | 10000.0"
    ],
    "difficulty": "Lv2 초급",
    "kind": "python",
    "expected": ["join", "groupBy", "agg"],
    "hint": "join 후 groupBy로 집계하고 count, sum 집계함수를 사용하세요."
  },
  {
    "pid": "pyspark_window",
    "title": "이동 평균 계산",
    "body": "time, value 컬럼을 가진 DataFrame에서 최근 3개 행의 이동 평균 rolling_avg 컬럼을 추가하세요.",
    "schema": "events(time TIMESTAMP, value DOUBLE)",
    "sample_rows": [
      "2024-03-01 10:00 | 10.0",
      "2024-03-01 10:05 | 14.0",
      "2024-03-01 10:10 | 12.0",
      "2024-03-01 10:15 | 16.0"
    ],
    "difficulty": "Lv3 중급",
    "kind": "python",
    "expected": ["Window", "rowsBetween", "avg"],
    "hint": "Window.orderBy('time').rowsBetween(-2, 0) 범위로 avg를 계산하세요."
  },
  {
    "pid": "pyspark_pivot",
    "title": "주간 상태별 집계 피벗",
    "body": "logs DataFrame(timestamp, status)에 대해 주차별(status별) 건수를 피벗 형태로 계산하세요. week, success, fail 같은 컬럼이 나오도록 만드세요.",
    "schema": "logs(timestamp TIMESTAMP, status STRING)",
    "sample_rows": [
      "2024-01-02 | success",
      "2024-01-03 | fail",
      "2024-01-08 | success",
      "2024-01-10 | success"
    ],
    "difficulty": "Lv4 고급",
    "kind": "python",
    "expected": ["groupBy", "pivot", "count", "date_trunc"],
    "hint": "week 컬럼을 date_trunc('week', timestamp)로 만든 뒤 pivot(status) 후 count 합니다."
  },
  {
    "pid": "pyspark_sessionize",
    "title": "세션 분리하여 페이지뷰 집계",
    "body": "pageviews(user_id, ts)에서 사용자별 30분 이상 끊기면 새로운 세션이라고 가정할 때, 세션 번호 session_id를 붙이고 세션당 페이지뷰 수를 집계하세요.",
    "schema": "pageviews(user_id INT, ts TIMESTAMP)",
    "sample_rows": [
      "1 | 2024-01-01 10:00",
      "1 | 2024-01-01 10:10",
      "1 | 2024-01-01 11:00",
      "2 | 2024-01-03 09:00"
    ],
    "difficulty": "Lv5 심화",
    "kind": "python",
    "expected": ["Window", "lag", "when", "sum", "over"],
    "hint": "user_id 파티션에서 lag(ts)로 이전 시각과 차이를 구하고, when으로 세션 리셋 플래그를 만든 뒤 sum를 over 으로 누적합니다."
  }
]
